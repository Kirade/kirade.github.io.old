---
layout: "post"
title: "[Python] 객체 복사하기 (copy, deepcopy)"
date: "2019-04-08 09:07"
category: Python
tags: Python
---

## Background
`a = 'python'`과 같이 파이썬이 변수에 어떤 객체를 할당 할 때에는 객체의 사본을 만들지 않고 이름만 연결을 하게됩니다. 따라서, 만약 할당되는 객체가 변경할 수 없는 객체(Immutable)라면 일반적인 할당으로도 의도한대로 동작합니다.

반면, 변경 가능한 객체 또는 변경 가능한 객체의 컬렉션을 다룰 때는 단순히 할당문을 이용하여 할당을 할 경우 의도한대로 코드가 동작하지 않을 수 있습니다.

코드들을 프로그래머가 의도한 대로 동작시키기 위해서는 파이썬에서 객체들을 어떻게 객체 복사 방식을 이해할 필요가 있습니다.

파이썬에서는 크게 복사 방식을 얕은 복사(copy)와 깊은 복사(deepcopy)로 나눌 수 있습니다. 이번 포스팅에서는 파이썬의 얕은 복사(copy)와 깊은 복사(deepcopy)의 동작을 알아보겠습니다.

---

## Study

#### 얕은 복사(copy), 깊은 복사(deepcopy)
`new_list = list(original_list)`
`new_dict = dict(original_dict)`
`new_set = list(original_set)`

위와 같이 변경 가능한(Mutable) 내장 컬렉션은 팩터리함수에 기존 컬랙션을 전달하여 복사할 수 있습니다. 이는 앞서 언급한 일반적인 할당 방식으로 앞서 언급한 복사 방식 중 **얕은 복사** 방식 입니다.

얕은 복사는 '한 단계 깊이'까지 객체를 복사하게 됩니다. 즉 위의 예제의 할당 방식으로 객체를 복사하게 되면 한 단계 깊이의 객체는 복사되지만 그 객체가 가지고 있는 자식들은 복사되지 않습니다.

반면, 깊은 복사는 얕은 복사 방식에서 추가적으로 자식들을 재귀적으로 복사하는 동작을 수행하여 변경 가능한 객체들의 자식들까지 복사할 수 있습니다.

#### 얕은 복사본

```python
xs = [[1,2,3], [4,5,6,], [7,8,9]]
ys = list(xs)
```
일반적인 할당방식으로 자식으로 리스트 객체를 가지고있는 `xs`리스트를 `ys`변수에 컬렉션 팩토리를 이용하여 복사하였습니다.

```python
xs = [[1,2,3], [4,5,6,], [7,8,9]]
ys = [[1,2,3], [4,5,6,], [7,8,9]]
```
따라서, 다음 변수들을 호출해보면 `xs`, `ys`가 같은 내용을 가지고 있는것을 볼 수 있습니다.

만약, `xs`리스트에 새로운 엘리먼트를 추가하게 되면 어떻게 될까요?
```python
xs.append(['new sublist'])
xs = [[1,2,3], [4,5,6,], [7,8,9], ['new sublist']]
ys = [[1,2,3], [4,5,6,], [7,8,9]]
```
예상했던 대로, `xs`에만 새로 추가한 엘리먼트가 추가되었습니다.

처음에 `ys`가 `xs`의 원본 자식 객체에 대한 얕은 복사를 하여 원본이 처음 가지고있던 자식 객체들에 대한 참조만 들고 있기 떄문에, `xs`에서 자식을 추가하여도 `ys`에서는 변화가 없습니다.

그렇다면, `ys`가 `xs`로부터 복사해혼 `xs`의 자식들의 변경이 일어나면 어떨까요?
```python
xs[1][0] = 'X'
xs = [[1,2,3], ['X',5,6,], [7,8,9], ['new sublist']]
ys = [[1,2,3], ['X',5,6,], [7,8,9]]
```
`xs`의 자식을 변경했을 뿐인데, `ys`가 가지고있는 자식도 변경되었습니다. 이는 앞서 언급했듯이 `ys`는 `xs`의 자식들을 복사한것이 아니라 참조를 그대로 들고있기 때문입니다.

얕은 복사는 이와같이 동작합니다.

#### 깊은 복사본

앞서 얕은 복사본에서는 '한 단계 깊이'의 객체만 복사되고 자식 객체들은 복사되지 않는 다는것을 확인했습니다.

앞으로 소개할 얕은 복사와 다르게 자식객체들까지 복사 할 수 있는 깊은 복사는  파이썬 표준 라이브러리인 `copy` 모듈을 사용합니다.

```python
import deepcopy
xs = [[1,2,3], [4,5,6,], [7,8,9]]
zx = copy.deepcopy(xs)
```
앞의 얕은 복사와 다른 점은 일반적인 팩토리를 사용한 할당이 아닌 `copy.deepcopy`를 사용하여 할당했다는 점입니다.

```python
xs = [[1,2,3], [4,5,6,], [7,8,9]]
zs = [[1,2,3], [4,5,6,], [7,8,9]]
```
내용을 출력해보면 얕은 복사와 동일하게 표시됩니다. 하지만 깊은 복사를 사용하게 되면 자식 객체들까지 복사가 된다고 했습니다. 따라서, 앞서 얕은 복사에서 했던 자식객체를 변경하는 실험을 했을 때 얕은 복사와 다른 결과가 나오리라는 것을 예상할 수 있습니다.

```python
xs[1][0] = 'X'
xs = [[1,2,3], ['X',5,6,], [7,8,9]]
zs = [[1,2,3], [4,5,6,], [7,8,9]]
```
`xs`의 자식 객체의 내용이 변화했는데, `copy.deepcopy`로 복사한 `zs`는 그대로 자신의 자식 객체를 유지하고 있습니다.


#### 정리
- 객체의 얕은 복사본을 만들면 자식 객체는 복사되지 않습니다. 따라서 사본은 원본과 완전히 독립적이지 않습니다.
- 깊은 복사는 재귀적으로 원본의 자식 객체들을 복사합니다. 따라서 사본이 원본과 독립적입니다.


---

## Reference
- Python Tricks The Book - 댄 베이더
