---
layout: "post"
title: "[CS] 프로세스와 메모리"
date: "2018-02-16 18:19"
category: "Computer Science"
tags: Process Memory OS System
---

## Background
이번 포스팅은 프로세스와 메모리를 공부하면서 한 이해를 바탕으로 프로세스가 실행될때 할당되는 메모리와 관련된 내용을 담았습니다.

---
## Study

### 기억장치
프로세스와 메모리의 관계를 이해하기 위해서는 몇 가지 사전 지식들이 필요합니다. 그 중 가장 기초가 되는것은 주기억장치와 보조기억장치라는 용어입니다.

주기억장치는 크게 ROM과 RAM으로 나뉘어 집니다. ROM의 특징은 Read-Only-Memory로서 메모리에 로드되어 있는 정보들을 읽는것만 가능하고 비휘발성이라 컴퓨터가 종료되어도 데이터가 손실되지 않는 특징이 있습니다.

반대로 RAM은 Random-Access-Memory로서 ROM과 다르게 전력 공급이 없어지면 가지고 있던 내용을 잃는 휘발성 메모리입니다. 또한, 읽고 쓰는 작업이 가능합니다. RAM이라는 기억장치가 바로 컴퓨터 사양에 스펙으로 자주 등장하는 메모리입니다.

보조기억장치는 일반적으로 알려진 디스크 형태의 기억장치 입니다. 이전에 사용하던 플로피 디스크부터 HDD, SSD에 이르기까지 주 기억장치에 비해 큰 용량을 가지지만 상대적으로 느린 처리속도를 가지고있는 기억장치입니다.

### 프로세스와 쓰레드의 메모리
프로세스가 실행되면 프로그램이 동작하는데 필요한 정보를 저장하기 위한 공간을 할당 받는다. 이 공간은 각각의 프로세스별로 코드, 데이터, 스택, 힙 영역으로 나뉘어 관리되어집니다. 즉, 다른 프로세스와는 서로 자원을 공유하지 않습니다. 하지만 프로세스 안에 여러개가 존재할 수 있는 쓰레드는 스택 영역을 제외한 메모리를 다른 쓰레드와 공유하여 사용할 수 있습니다.

### 논리 메모리, 물리 메모리
프로세스가 메모리에 할당 된다면 각각의 프로세스는 동일한 크기의 메모리를 할당 받습니다. 또한 각 프로세스 별로 0x00000000 ~ 0xFFFFFFFF 범위의 메모리 영역을 사용합니다. 즉, A 프로세스에서 0x12345678 메모리 영역에 변수를 할당하고, 다른 프로세스인 B 프로세스에서도 0x12345678에 변수를 할당할 수 있습니다. 여기서 프로세스가 가진 주소가 논리 메모리의 주소입니다. 반면, 물리 주소는 실제 메모리의 주소입니다.

결국, 프로세스는 일정 영역의 메모리를 할당 받고 사용하지만 사용하는 메모리의 주소는 실제 메모리의 주소와는 다릅니다. 따라서, 주소가 다른 문제점이 발생하는데 이것을 각 프로세스별로 가지고있는 논리 메모리와 물리메모리 매핑 테이블을 통해 해결합니다.

### 가상 메모리
일반적으로 프로세스에 공간이 할당 된다면 32비트 운영체제에서는 4GB, 64비트 프로세스는 16EB를 각각의 프로세스가 가질 수 있도록 합니다. 하지만 4GB, 16EB라는 크기는 하나의 프로세스가 다 사용하기에는 굉장히 큰 수치입니다. 만약 32비트 컴퓨터에 8GB 메모리가 꽂혀있다고하면, 잘해봐야 2개의 프로세스를 실행할 수 있을 것입니다. 논리 메모리는 굉장히 크지만 사용할 수 있는 물리 메모리의 크기는 굉장히 제한적입니다. 바로 이런 한계를 극복하기 위한 기술이 가상 메모리 입니다.

가상 메모리는 프로세스에서 필요한 부분만 메모리로 올리는 Demand-Paging 기법을 사용합니다. 또한 나머지 부분들은 디스크 공간을 가상의 메모리처럼 활용하여 데이터를 저장하게 됩니다. 이를 통해 각각의 프로세스는 독립된 메모리 공간을 가지게되고 한정된 물리 메모리의 한계를 극복하여 실행되는 프로세스에 여유로운 메모리 공간을 주게됩니다.

### Page
페이지란 가상 메모리를 사용하는 단위입니다. 윈도우 에서는 4KB를 기준으로 정해두었습니다. 만약 페이지라는 단위가 없었을 경우에 디스크에서 메모리로 데이터를 로드할 때, 데이터의 크기가 제각각이므로 중간중간 비는 공간(Fragmentation)이 발생합니다. 따라서 이를 줄이기 위해 페이지라는 단위를 사용합니다.

### Demand-Paging
앞서 가상 메모리에서 소개한 Demand-Paging이라는 것은 메모리에 실제 필요한 Page를 가져오는 방식을 말합니다. 필요한 Page에 접근하려면 가상 메모리 주소 즉, 논리 메모리주소를 물리 메모리 주소로 변환하는 과정이 필요합니다. 이를 페이지 테이블을 통해 수행합니다.

페이지 테이블을 참조하여 페이징을 수행할 때 크게 두 가지 경우가 발생할 수 있습니다. valid bit를 통해 물리 메모리에 있다면 문제없이 필요한 작업을 수행합니다. 하지만 필요한 페이지가 물리 메모리에 존재하지 않는다면, 가상 메모리 기법을 통해 디스크로 옮겨져 있던 페이지를 가져옵니다.

하지만, 이 경우에도 문제가 발생할 여지가 있습니다. 만약 물리 메모리가 가득차서 더이상 페이지를 넣을 공간이 없다면 어떻게 할 것인가에 관한 문제입니다. 이런 문제는 여러 Page replacement algorithm 중의 하나로 해결합니다. FIFO, LRU, LRU Approximate 등 다양한 알고리즘이 존재하지만 LRU Approximate가 효율이 좋다고 알려져 있습니다.


---
## Reference
* [Virtual Mememory - egloos](http://sweeper.egloos.com/2988689)
